#!/usr/bin/env python3

# Prompt Manager CLI Tool
# Manages and displays prompts from multiple sources with variable substitution support

import argparse
import json
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Base directory for prompt sources
BASE_DIR = Path.home() / ".dotfiles" / "repos" / "public"
AICHAT_ROLES_DIR = BASE_DIR / "ai" / "aichat" / "roles"
CURSOR_COMMANDS_DIR = BASE_DIR / "ai" / "cursor" / "commands"
SNIPPETS_FILE = BASE_DIR / "nvim" / "snippets" / "markdown.json"


def discover_prompts() -> Dict[str, Dict]:
    """Scan all sources and build prompt registry."""
    prompts = {}

    # Scan aichat roles
    if AICHAT_ROLES_DIR.exists():
        for md_file in AICHAT_ROLES_DIR.glob("*.md"):
            name = f"aichat-role/{md_file.stem}"
            prompts[name] = {
                "type": "markdown",
                "path": md_file,
                "prefix": "aichat-role/"
            }

    # Scan cursor commands
    if CURSOR_COMMANDS_DIR.exists():
        for md_file in CURSOR_COMMANDS_DIR.glob("*.md"):
            name = f"cursor-command/{md_file.stem}"
            prompts[name] = {
                "type": "markdown",
                "path": md_file,
                "prefix": "cursor-command/"
            }

    # Parse snippets file
    if SNIPPETS_FILE.exists():
        try:
            with open(SNIPPETS_FILE, 'r', encoding='utf-8') as f:
                snippets_data = json.load(f)

            for key, snippet in snippets_data.items():
                # Only include snippets that start with "Prompt ➤ "
                if not key.startswith("Prompt ➤ "):
                    continue
                # Remove "Prompt ➤ " prefix from key
                clean_key = key.replace("Prompt ➤ ", "", 1)
                name = f"snippets/{clean_key}"
                prompts[name] = {
                    "type": "snippet",
                    "key": key,
                    "snippet": snippet,
                    "prefix": "snippets/"
                }
        except (json.JSONDecodeError, KeyError) as e:
            sys.stderr.write(f"Warning: Failed to parse snippets file: {e}\n")

    return prompts


def load_prompt(name: str, prompts_registry: Dict) -> Optional[str]:
    """Load prompt content from appropriate source."""
    if name not in prompts_registry:
        return None

    prompt_info = prompts_registry[name]

    if prompt_info["type"] == "markdown":
        try:
            with open(prompt_info["path"], 'r', encoding='utf-8') as f:
                return f.read()
        except IOError as e:
            sys.stderr.write(f"Error reading file {prompt_info['path']}: {e}\n")
            return None

    elif prompt_info["type"] == "snippet":
        snippet = prompt_info["snippet"]
        body = snippet.get("body", [])
        if isinstance(body, list):
            return "\n".join(body)
        return str(body)

    return None


def parse_snippet_variables(content: str) -> List[Tuple[str, str, Optional[str], Optional[List[str]]]]:
    """
    Parse VSCode snippet format variables.
    Returns list of (full_match, var_type, default_value, choices)
    var_type: 'simple', 'default', 'choice', 'tabstop'
    """
    variables = []

    # Pattern for ${N|choice1,choice2,choice3|} - choice variables
    choice_pattern = r'\$\{(\d+)\|([^}]+)\}'
    for match in re.finditer(choice_pattern, content):
        var_num = match.group(1)
        choices_str = match.group(2)
        choices = [c.strip() for c in choices_str.split(',')]
        variables.append((match.group(0), "choice", None, choices))

    # Pattern for ${N:default} - tabstop with default
    default_pattern = r'\$\{(\d+):([^}]*)\}'
    for match in re.finditer(default_pattern, content):
        var_num = match.group(1)
        default_val = match.group(2)
        variables.append((match.group(0), "default", default_val, None))

    # Pattern for $N - simple tabstop
    # First, collect all tabstop numbers already captured by choice/default patterns
    captured_tabstops = set()
    for var_match, var_type, _, _ in variables:
        if var_type in ["choice", "default"]:
            # Extract tabstop number from ${N|...} or ${N:...}
            tabstop_match = re.search(r'\$\{(\d+)', var_match)
            if tabstop_match:
                captured_tabstops.add(tabstop_match.group(1))

    tabstop_pattern = r'\$(\d+)'
    for match in re.finditer(tabstop_pattern, content):
        var_num = match.group(1)
        full_var = f"${var_num}"
        # Skip if this tabstop number was already captured by a choice/default pattern
        # (we'll handle it when processing those patterns)
        if var_num not in captured_tabstops:
            # Also check if we haven't already added this exact pattern
            if not any(v[0] == full_var for v in variables):
                variables.append((full_var, "tabstop", None, None))

    # Pattern for $VAR - named variables
    named_var_pattern = r'\$([A-Z_][A-Z0-9_]*)'
    for match in re.finditer(named_var_pattern, content):
        var_name = match.group(1)
        full_var = f"${var_name}"
        variables.append((full_var, "named", None, None))

    return variables


def get_known_variable_value(var_name: str) -> Optional[str]:
    """Get value for known variables that can be auto-substituted."""
    now = datetime.now()

    known_vars = {
        "CURRENT_YEAR": str(now.year),
        "CURRENT_MONTH": f"{now.month:02d}",
        "CURRENT_DATE": f"{now.day:02d}",
        "CURRENT_HOUR": f"{now.hour:02d}",
        "CURRENT_MINUTE": f"{now.minute:02d}",
    }

    return known_vars.get(var_name)


def substitute_variables(content: str, vars_dict: Dict[str, str], interactive: bool = True) -> str:
    """Handle variable substitution."""
    # Replace $TM_SELECTED_TEXT with __INPUT__
    content = content.replace("$TM_SELECTED_TEXT", "__INPUT__")

    # Replace __INPUT__ with value from vars_dict if provided
    if "__INPUT__" in vars_dict:
        content = content.replace("__INPUT__", vars_dict["__INPUT__"])

    # Parse all variables
    variables = parse_snippet_variables(content)

    # Sort by type priority: choice > default > tabstop > named
    type_priority = {"choice": 0, "default": 1, "tabstop": 2, "named": 3}
    variables.sort(key=lambda x: type_priority.get(x[1], 99))

    # Process variables
    for full_match, var_type, default_val, choices in variables:
        if full_match in content:
            value = None

            # Check if value provided via vars_dict
            # For tabstops, check both $N and the number
            if var_type in ["tabstop", "default", "choice"]:
                var_num = re.search(r'\d+', full_match).group(0)
                if var_num in vars_dict:
                    value = vars_dict[var_num]
                elif full_match in vars_dict:
                    value = vars_dict[full_match]
            else:
                # Named variable
                var_name = full_match[1:]  # Remove $
                if var_name in vars_dict:
                    value = vars_dict[var_name]
                elif full_match in vars_dict:
                    value = vars_dict[full_match]

            # Auto-substitute known variables
            if value is None and var_type == "named":
                var_name = full_match[1:]
                value = get_known_variable_value(var_name)

            # Use default value if available
            if value is None and default_val is not None:
                value = default_val

            # Handle choice variables
            if value is None and choices is not None:
                if interactive:
                    print(f"Choose a value for {full_match}:", file=sys.stderr)
                    for i, choice in enumerate(choices, 1):
                        print(f"  {i}. {choice}", file=sys.stderr)
                    try:
                        choice_num = input("Enter choice number: ").strip()
                        idx = int(choice_num) - 1
                        if 0 <= idx < len(choices):
                            value = choices[idx]
                        else:
                            value = choices[0] if choices else ""
                    except (ValueError, KeyboardInterrupt):
                        value = choices[0] if choices else ""
                else:
                    value = choices[0] if choices else ""

            # Prompt for other variables
            if value is None and interactive:
                prompt_text = f"Enter value for {full_match}"
                if default_val:
                    prompt_text += f" (default: {default_val})"
                prompt_text += ": "
                try:
                    value = input(prompt_text).strip()
                    if not value and default_val:
                        value = default_val
                except KeyboardInterrupt:
                    value = default_val if default_val else ""

            # If still no value, use empty string
            if value is None:
                value = ""

            # Replace all occurrences in content
            content = content.replace(full_match, value)

            # For choice/default variables, also replace simple tabstop instances
            # e.g., if we processed ${1:default}, also replace all $1 instances
            if var_type in ["choice", "default"]:
                var_num = re.search(r'\d+', full_match).group(0)
                simple_tabstop = f"${var_num}"
                # Only replace if it's a standalone $N, not part of ${N:...} or ${N|...}
                # Use word boundary-like matching to avoid replacing inside other patterns
                content = re.sub(r'\$' + re.escape(var_num) + r'(?![|:}])', value, content)

    return content


def list_prompts(prompts_registry: Dict):
    """List all available prompts."""
    for name in sorted(prompts_registry.keys()):
        print(name)


def print_prompt(name: str, prompts_registry: Dict, vars_dict: Dict[str, str], interactive: bool = True):
    """Print prompt content with variable substitution."""
    content = load_prompt(name, prompts_registry)
    if content is None:
        sys.stderr.write(f"Error: Prompt '{name}' not found.\n")
        sys.exit(1)

    substituted = substitute_variables(content, vars_dict, interactive)
    print(substituted, end="")


def choose_prompt(prompts_registry: Dict, vars_dict: Dict[str, str], interactive: bool = True):
    """Use fzf to interactively select and print a prompt."""
    # Get list of prompt names
    prompt_names = sorted(prompts_registry.keys())

    if not prompt_names:
        sys.stderr.write("No prompts found.\n")
        sys.exit(1)

    # Prepare input for fzf
    prompt_list = "\n".join(prompt_names)

    try:
        # Run fzf
        result = subprocess.run(
            ["fzf"],
            input=prompt_list,
            text=True,
            capture_output=True,
            check=False
        )

        if result.returncode == 0 and result.stdout.strip():
            selected = result.stdout.strip()
            print_prompt(selected, prompts_registry, vars_dict, interactive)
        elif result.returncode == 130:  # Ctrl+C
            sys.exit(130)
        elif result.returncode == 1:  # No selection
            sys.exit(0)
        else:
            sys.exit(result.returncode)

    except FileNotFoundError:
        sys.stderr.write("Error: fzf not found. Please install fzf to use the choose command.\n")
        sys.exit(1)


def parse_args(args=None):
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Prompt Manager - List and print prompts from multiple sources'
    )

    subparsers = parser.add_subparsers(dest='command', help='Subcommands')

    # Choose command (default)
    choose_parser = subparsers.add_parser('choose', help='Interactively select a prompt using fzf (default)')
    choose_parser.add_argument('--var', action='append', metavar='KEY=VALUE',
                              help='Provide variable values (can be used multiple times)')
    choose_parser.add_argument('--input', metavar='TEXT',
                              help='Value for __INPUT__ (replaces $TM_SELECTED_TEXT)')
    choose_parser.add_argument('--no-interactive', action='store_true',
                              help='Disable interactive variable prompting')

    # List command
    list_parser = subparsers.add_parser('list', help='List all available prompts')

    # Print command
    print_parser = subparsers.add_parser('print', help='Print a specific prompt')
    print_parser.add_argument('name', help='Prompt name (e.g., aichat-role/git-commit)')
    print_parser.add_argument('--var', action='append', metavar='KEY=VALUE',
                             help='Provide variable values (can be used multiple times)')
    print_parser.add_argument('--input', metavar='TEXT',
                             help='Value for __INPUT__ (replaces $TM_SELECTED_TEXT)')
    print_parser.add_argument('--no-interactive', action='store_true',
                             help='Disable interactive variable prompting')

    parsed_args = parser.parse_args(args)

    # If no command provided, default to choose
    if parsed_args.command is None:
        parsed_args.command = 'choose'
        # Create a namespace with default values for choose
        if not hasattr(parsed_args, 'var'):
            parsed_args.var = None
        if not hasattr(parsed_args, 'input'):
            parsed_args.input = None
        if not hasattr(parsed_args, 'no_interactive'):
            parsed_args.no_interactive = False

    return parsed_args


def parse_vars(vars_list: Optional[List[str]]) -> Dict[str, str]:
    """Parse --var KEY=VALUE arguments into a dictionary."""
    vars_dict = {}
    if vars_list:
        for var_arg in vars_list:
            if '=' in var_arg:
                key, value = var_arg.split('=', 1)
                vars_dict[key] = value
            else:
                vars_dict[var_arg] = ""
    return vars_dict


def main():
    """Main entry point."""
    args = parse_args()

    # Build prompts registry
    prompts_registry = discover_prompts()

    # Parse variables (only for commands that support them)
    vars_dict = {}
    if hasattr(args, 'var') and args.var:
        vars_dict = parse_vars(args.var)
    if hasattr(args, 'input') and args.input:
        vars_dict["__INPUT__"] = args.input

    # Execute command
    interactive = True
    if hasattr(args, 'no_interactive'):
        interactive = not args.no_interactive

    if args.command == 'list':
        list_prompts(prompts_registry)
    elif args.command == 'print':
        print_prompt(args.name, prompts_registry, vars_dict, interactive)
    elif args.command == 'choose':
        choose_prompt(prompts_registry, vars_dict, interactive)
    else:
        sys.stderr.write(f"Unknown command: {args.command}\n")
        sys.exit(1)


if __name__ == '__main__':
    main()
