#!/usr/bin/env python3
"""Display git branches in a tree structure based on git log graph."""

import re
import subprocess
import sys
from collections import defaultdict
from io import StringIO


def run_git(*args):
    """Run a git command and return stdout."""
    result = subprocess.run(
        ["git"] + list(args),
        capture_output=True,
        text=True,
    )
    return result.stdout.strip() if result.returncode == 0 else ""


def get_current_branch():
    """Get the current branch name."""
    branch = run_git("branch", "--show-current")
    if branch:
        return branch
    return run_git("rev-parse", "--short", "HEAD")


def get_git_log():
    return run_git(
        "log", "--graph", "--simplify-by-decoration",
        "--pretty=format:%d", "--branches",
        "--decorate-refs", "refs/heads/*",
    )


def get_star_column(line):
    """Get the column (string position) of '*'."""
    return line.find('*')


def parse_branch_name(line):
    """Extract branch name from (branch-name) in the line."""
    match = re.search(r"\(([^)]+)\)", line)
    return match.group(1) if match else None


def is_root_candidate(line):
    """Check if line is a root candidate: starts with '* ' and has no '|'."""
    return line.startswith("* ") and "|" not in line


def is_merge_line(line):
    """Check if line is a merge marker (contains / but no branch name)."""
    # Merge lines look like |/ or | |/ - they have / but no (branch)
    return "/" in line and "(" not in line


def get_slash_column(line):
    """Get the column (string position) of '/'."""
    return line.find('/')


def format_branch(branch, current, level, is_stalled=False):
    """Format a branch line with indentation."""
    indent = "    " * level
    suffix = " (stalled)" if is_stalled else ""
    if branch == current:
        return f"{indent}* {branch}{suffix}"
    else:
        return f"{indent}  {branch}{suffix}"


def parse_branches(lines, skip_branches=None, debug=False):
    """Parse branch tree from git log lines in a single pass.

    Algorithm:
    - children_at_col[col] = list of (branch_idx, children_list) awaiting parent at column col
    - For each branch at column col:
      - All items in children_at_col[col] become its children
      - Clear children_at_col[col] and append this branch
    - For each merge '/' at column col:
      - Move last item from children_at_col[col+1] to children_at_col[col-1]

    Returns: (branches, children)
    """
    if skip_branches is None:
        skip_branches = set()

    branches = []
    children = defaultdict(list)
    children_at_col = defaultdict(list)

    for line in lines:
        if is_merge_line(line):
            col = get_slash_column(line)
            if children_at_col[col + 1]:
                child_idx = children_at_col[col + 1].pop()
                if col - 1 >= 0:
                    children_at_col[col - 1].append(child_idx)
            if debug:
                print(f"    MERGE: col={col}, children_at_col[{col+1}]={children_at_col[col+1]}, children_at_col[{col-1}]={children_at_col[col-1]}")
            continue

        branch = parse_branch_name(line)
        if not branch:
            continue
        if branch in skip_branches:
            break

        col = get_star_column(line)
        idx = len(branches)
        branches.append(branch)

        if debug:
            print(f"    BRANCH: {branch} col={col}, children={children_at_col[col]}")
        for child_idx in children_at_col[col]:
            children[idx].append(child_idx)
        children_at_col[col].clear()
        children_at_col[col].append(idx)


    return branches, children


def find_roots(branches, children):
    """Find root branches (not children of any other branch)."""
    all_children = set()
    for child_list in children.values():
        all_children.update(child_list)
    return [i for i in range(len(branches)) if i not in all_children]


def format_tree(branches, children, idx, level, current, is_stalled=False):
    """Recursively format branch tree, returning list of lines."""
    lines = [format_branch(branches[idx], current, level, is_stalled)]
    if idx in children:
        for child_idx in reversed(children[idx]):
            lines.extend(format_tree(branches, children, child_idx, level + 1, current, is_stalled))
    return lines


def process_git_log(log_output, current, debug=False):
    """Process git log output and return formatted tree lines.

    Args:
        log_output: Git log graph output string
        current: Current branch name
        debug: Print debug info

    Returns:
        List of formatted output lines
    """
    if not log_output:
        return ["No branches found"]

    lines = log_output.split("\n")
    output = []

    # Find merge_base (root) - second branch that starts with '* ' and has no '|'
    root_candidate_count = 0
    merge_base = None
    merge_base_line_idx = None

    for i, line in enumerate(lines):
        branch = parse_branch_name(line)
        if not branch:
            continue

        if is_root_candidate(line):
            root_candidate_count += 1
            merge_base = branch
            merge_base_line_idx = i
            if root_candidate_count == 0:
                break
        else:
            root_candidate_count = -1

    if debug:
        print(f"  DEBUG: merge_base={merge_base}, merge_base_line_idx={merge_base_line_idx}")

    # Split lines into fresh (before merge_base) and stalled (after merge_base)
    if merge_base_line_idx is not None:
        fresh_lines = lines[:merge_base_line_idx]
        stalled_lines = lines[merge_base_line_idx + 1:]
    else:
        fresh_lines = lines
        stalled_lines = []

    if debug:
        print(f"  DEBUG: fresh_lines count={len(fresh_lines)}")

    # Parse branches
    fresh_branches, fresh_children = parse_branches(fresh_lines, debug=debug)
    skip_stalled = {"main", "master"}
    stalled_branches, stalled_children = parse_branches(stalled_lines, skip_stalled)

    if debug:
        print(f"  DEBUG: fresh_branches={fresh_branches}")
        print(f"  DEBUG: fresh_children={dict(fresh_children)}")

    # Format output
    if merge_base:
        output.append(format_branch(merge_base, current, 0))

    # Stalled branches
    stalled_roots = find_roots(stalled_branches, stalled_children)
    for idx in reversed(stalled_roots):
        output.extend(format_tree(stalled_branches, stalled_children, idx, 1, current, is_stalled=True))

    # Fresh branches
    fresh_roots = find_roots(fresh_branches, fresh_children)
    if debug:
        print(f"  DEBUG: fresh_roots={fresh_roots}")
    for idx in reversed(fresh_roots):
        output.extend(format_tree(fresh_branches, fresh_children, idx, 1, current, is_stalled=False))

    return output


def main():
    current = get_current_branch()
    log_output = get_git_log()

    for line in process_git_log(log_output, current):
        print(line)


# =============================================================================
# Tests
# =============================================================================

# def run_tests(debug=False):
#     """Run embedded tests."""
#     import textwrap

#     def test(name, log_input, current, expected):
#         log = textwrap.dedent(log_input).strip()
#         expected_lines = textwrap.dedent(expected).strip()
#         if not expected_lines.startswith("* "):
#             expected_lines = textwrap.indent(expected_lines, "  ")
#         expected_lines = expected_lines.split("\n")
#         actual_lines = process_git_log(log, current, debug=debug)

#         if actual_lines == expected_lines:
#             print(f"✓ {name}")
#             return True
#         else:
#             print(f"✗ {name}")
#             print(f"  Expected lines:")
#             for i, line in enumerate(expected_lines):
#                 print(f"    {i}: {repr(line)}")
#             print(f"  Actual lines:")
#             for i, line in enumerate(actual_lines):
#                 print(f"    {i}: {repr(line)}")
#             return False

#     results = []

#     # Test 1: Simple branch hierarchy
#     results.append(test(
#         "Simple hierarchy",
#         """
#         *  (fix-over-paid-invoice)
#         | *  (feature/auto-accept-log)
#         |/
#         | *  (feature/cch-verifications)
#         | *  (feature/cch-order-fsm)
#         |/
#         *  (develop)
#         *  (main)
#         """,
#         "develop",
#         """
#         * develop
#               feature/cch-order-fsm
#                   feature/cch-verifications
#               feature/auto-accept-log
#               fix-over-paid-invoice
#         """
#     ))

#     # Test 2: Nested children
#     results.append(test(
#         "Nested children (grandchild)",
#         """
#         *  (fix-over-paid-invoice)
#         | *  (feature/auto-accept-log)
#         |/
#         | *  (feature/cch-verifications)
#         | | *  (feature/new-grandson)
#         | |/
#         | *  (feature/cch-order-fsm)
#         |/
#         *  (develop)
#         """,
#         "develop",
#         """
#         * develop
#               feature/cch-order-fsm
#                   feature/new-grandson
#                   feature/cch-verifications
#               feature/auto-accept-log
#               fix-over-paid-invoice
#         """
#     ))

#     # Test 3: Current branch marker
#     results.append(test(
#         "Current branch marker",
#         """
#         *  (fix-over-paid-invoice)
#         | *  (feature/auto-accept-log)
#         |/
#         *  (develop)
#         """,
#         "feature/auto-accept-log",
#         """
#           develop
#             * feature/auto-accept-log
#               fix-over-paid-invoice
#         """
#     ))

#     # Test 4: Complex hierarchy with multiple children
#     # Note: The git graph has complex patterns like * | and |/| which result in
#     # auto-accept-log becoming a child of cch-verifications in the parsed tree
#     results.append(test(
#         "Complex hierarchy",
#         """
#         *  (feature/extra-child-2)
#         | *  (feature/grandchild-1b)
#         | | *  (feature/grandchild-1a)
#         | |/
#         | *  (feature/extra-child-1)
#         |/
#         | *  (feature/auto-accept-log)
#         | | *  (fix-over-paid-invoice)
#         | |/
#         | | *  (feature/new-grandson)
#         | |/
#         |/|
#         * |  (feature/cch-verifications)
#         * |  (feature/cch-order-fsm)
#         |/
#         *  (develop)
#         """,
#         "develop",
#         """
#         * develop
#               feature/cch-order-fsm
#                   feature/cch-verifications
#                       feature/new-grandson
#                       feature/extra-child-1
#                           feature/grandchild-1a
#                           feature/grandchild-1b
#                       feature/extra-child-2
#               fix-over-paid-invoice
#               feature/auto-accept-log
#         """
#     ))

#     # Summary
#     passed = sum(results)
#     total = len(results)
#     print(f"\n{passed}/{total} tests passed")
#     return passed == total


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        debug = len(sys.argv) > 2 and sys.argv[2] == "--debug"
        success = run_tests(debug=debug)
        sys.exit(0 if success else 1)
    else:
        main()
