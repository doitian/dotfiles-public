#!/usr/bin/env python3
"""Display git branches in a tree structure based on git log graph."""

import re
import subprocess
import sys


def run_git(*args):
    """Run a git command and return stdout."""
    result = subprocess.run(
        ["git"] + list(args),
        capture_output=True,
        text=True,
    )
    return result.stdout.strip() if result.returncode == 0 else ""


def get_merge_base_ref():
    """Get the merge base reference (upstream/HEAD, origin/HEAD, or develop/main/master)."""
    for cmd in [
        ["symbolic-ref", "refs/remotes/upstream/HEAD"],
        ["symbolic-ref", "refs/remotes/origin/HEAD"],
    ]:
        ref = run_git(*cmd)
        if ref:
            ref = re.sub(r"^refs/remotes/[^/]+/", "", ref)
            ref = re.sub(r"^refs/heads/", "", ref)
            return ref

    # Fallback to develop, main, or master
    for branch in ["main", "master", "develop"]:
        if run_git("rev-parse", "--verify", branch):
            return branch

    return "main"


def get_current_branch():
    """Get the current branch name."""
    branch = run_git("branch", "--show-current")
    if branch:
        return branch
    return run_git("rev-parse", "--short", "HEAD")


def get_git_log(merge_base_ref):
    """Get git log graph output."""
    # Try with ref~.. first, then ref.., then no constraint
    for rev_range in [f"{merge_base_ref}^..", f"{merge_base_ref}.."]:
        output = run_git(
            "log", "--graph", "--simplify-by-decoration",
            "--pretty=format:%d", "--branches",
            "--decorate-refs", "refs/heads/*",
            rev_range,
        )
        if output:
            return output

    # Final fallback: no range constraint
    return run_git(
        "log", "--graph", "--simplify-by-decoration",
        "--pretty=format:%d", "--branches",
        "--decorate-refs", "refs/heads/*",
    )


def count_pipes(line):
    """Count the number of '| ' before '*' to determine column depth."""
    match = re.match(r"^([\| ]*)\*", line)
    if match:
        prefix = match.group(1)
        return prefix.count("| ")
    return -1


def parse_branch_name(line):
    """Extract branch name from (branch-name) in the line."""
    match = re.search(r"\(([^)]+)\)", line)
    return match.group(1) if match else None


def is_root_candidate(line):
    """Check if line is a root candidate: starts with '* ' and has no '|'."""
    return line.startswith("* ") and "|" not in line


def is_merge_line(line):
    """Check if line is a merge marker (contains /)."""
    return "/" in line


def get_merge_column(line):
    """Get the column where merge happens."""
    prefix = re.sub(r"/.*", "", line)
    return prefix.count("| ") + 1


def print_branch(branch, current, level, is_stalled=False):
    """Print a branch with indentation."""
    indent = "    " * level
    suffix = " (stalled)" if is_stalled else ""
    marker = "*" if branch == current else " "
    print(f"{indent}{marker} {branch}{suffix}")


def parse_branches(lines, current, skip_branches=None):
    """Parse branch tree from git log lines.

    Returns: (branches, parent_of, children)
    - branches: list of branch names
    - parent_of: dict mapping child_idx -> parent_idx
    - children: dict mapping parent_idx -> list of child_idx
    """
    if skip_branches is None:
        skip_branches = set()

    branches = []
    parent_of = {}
    stack = {}

    for line in lines:
        # Handle merge markers
        if is_merge_line(line):
            merge_col = get_merge_column(line)
            stack = {c: idx for c, idx in stack.items() if c < merge_col}
            continue

        branch = parse_branch_name(line)
        if not branch or branch in skip_branches:
            continue

        col = count_pipes(line)
        idx = len(branches)
        branches.append(branch)

        # Parent is the branch at col-1 (if exists)
        if col - 1 in stack:
            parent_of[idx] = stack[col - 1]

        # If there's a pending branch at same column, its parent is this one
        if col in stack:
            pending_child = stack[col]
            parent_of[pending_child] = idx

        # This branch is now pending at its column
        stack[col] = idx

    # Build children map
    children = {}
    for child_idx, parent_idx in parent_of.items():
        if parent_idx not in children:
            children[parent_idx] = []
        children[parent_idx].append(child_idx)

    return branches, parent_of, children


def print_tree(branches, children, idx, level, current, is_stalled=False):
    """Recursively print branch tree."""
    branch = branches[idx]
    print_branch(branch, current, level, is_stalled)
    if idx in children:
        # Print children in reverse order (oldest first)
        for child_idx in reversed(children[idx]):
            print_tree(branches, children, child_idx, level + 1, current, is_stalled)


def main():
    merge_base_ref = get_merge_base_ref()
    current = get_current_branch()
    log_output = get_git_log(merge_base_ref)

    if not log_output:
        print("No branches found")
        return

    lines = log_output.split("\n")

    # First pass: find last_leaf and merge_base (root)
    last_leaf = None
    merge_base = None
    merge_base_line_idx = None

    for i, line in enumerate(lines):
        branch = parse_branch_name(line)
        if not branch:
            continue

        if is_root_candidate(line):
            if last_leaf is None:
                last_leaf = branch
            elif merge_base is None:
                merge_base = branch
                merge_base_line_idx = i
                break

    # Split lines into fresh (before merge_base) and stalled (after merge_base)
    if merge_base_line_idx is not None:
        fresh_lines = lines[:merge_base_line_idx]
        stalled_lines = lines[merge_base_line_idx + 1:]
    else:
        fresh_lines = lines
        stalled_lines = []

    # Parse fresh branches (skip last_leaf, will be printed at end)
    skip = {last_leaf} if last_leaf else set()
    fresh_branches, fresh_parent_of, fresh_children = parse_branches(fresh_lines, current, skip)

    # Parse stalled branches (skip main/master)
    skip_stalled = {"main", "master"}
    stalled_branches, stalled_parent_of, stalled_children = parse_branches(stalled_lines, current, skip_stalled)

    # Print merge base as root
    if merge_base:
        print_branch(merge_base, current, 0)

    # Print stalled branches tree (with +1 depth offset, marked as stalled)
    stalled_roots = [i for i in range(len(stalled_branches)) if i not in stalled_parent_of]
    for idx in reversed(stalled_roots):
        print_tree(stalled_branches, stalled_children, idx, 1, current, is_stalled=True)

    # Print fresh branches tree
    fresh_roots = [i for i in range(len(fresh_branches)) if i not in fresh_parent_of]
    for idx in reversed(fresh_roots):
        print_tree(fresh_branches, fresh_children, idx, 1, current, is_stalled=False)

    # Print last leaf
    if last_leaf:
        level = 0 if merge_base is None else 1
        print_branch(last_leaf, current, level)


if __name__ == "__main__":
    main()
