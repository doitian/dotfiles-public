#!/usr/bin/env bun
/**
 * Compile each bin entrypoint to a standalone executable in dist/.
 * Run: bun run build
 * Skips a target if it is newer than the source entry, mise.local.toml (if present), and all src/lib/*.
 */
import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync, statSync } from "node:fs";
import { join, resolve } from "node:path";

const pkg = JSON.parse(readFileSync("./package.json", "utf-8"));
const bin = pkg.bin;
if (!bin || typeof bin !== "object") {
    console.error("No bin map in package.json");
    process.exit(1);
}

const distDir = resolve(process.cwd(), "dist");
if (!existsSync(distDir)) {
    mkdirSync(distDir, { recursive: true });
}

// Generate src/lib/config.js with build-time defaults from env
function getEnvConfig(name) {
    const val = process.env[name];
    return val != null && val !== "" ? JSON.stringify(val) : "undefined";
}
const configVars = [
    ["DEFAULT_OPENAI_API_KEY", "OPENAI_API_KEY"],
    ["DEFAULT_OPENAI_BASE_URL", "OPENAI_BASE_URL"],
    ["DEFAULT_OPENAI_MODEL", "OPENAI_MODEL"],
    ["DEFAULT_PUSHOVER_USER_KEY", "PUSHOVER_USER_KEY"],
    ["DEFAULT_PUSHOVER_AGENT_TOKEN", "PUSHOVER_AGENT_TOKEN"],
    ["DEFAULT_PUSHOVER_PERSONAL_TOKEN", "PUSHOVER_PERSONAL_TOKEN"],
];
const configSource =
    `/**
 * Build-time defaults generated by build.js.
 * DO NOT EDIT â€” this file is gitignored and regenerated on build.
 */
` +
    configVars
        .map(([exportName, envName]) => `export const ${exportName} = ${getEnvConfig(envName)};`)
        .join("\n") +
    "\n";
const configPath = "./src/lib/config.js";
let existingConfig = "";
try {
    existingConfig = readFileSync(configPath, "utf-8");
} catch (_) { }
if (existingConfig !== configSource) {
    writeFileSync(configPath, configSource);
    console.log("Generated src/lib/config.js");
} else {
    console.log("src/lib/config.js unchanged");
}

// Merge package.json bin and private src into one list: { name, sourcePath, configSource? }
const entries = [];
for (const name of Object.keys(bin)) {
    entries.push({
        name,
        sourcePath: `./src/${name}.js`,
    });
}
const privateSrcDir = join(process.cwd(), "..", "private", "src");
if (existsSync(privateSrcDir)) {
    for (const f of readdirSync(privateSrcDir)) {
        if (!f.endsWith(".js")) continue;
        entries.push({
            name: f.slice(0, -3),
            sourcePath: join(privateSrcDir, f),
        });
    }
}

const libDir = join(process.cwd(), "src", "lib");
const miseLocalPath = join(process.cwd(), "mise.local.toml");

/** Return the newest mtime among source entry, mise.local.toml (if any), and all files in src/lib. */
function getNewestInputMtime(sourcePath) {
    let newest = 0;
    try {
        const s = statSync(sourcePath);
        if (s.mtimeMs > newest) newest = s.mtimeMs;
    } catch (_) { }
    if (existsSync(miseLocalPath)) {
        const m = statSync(miseLocalPath).mtimeMs;
        if (m > newest) newest = m;
    }
    if (existsSync(libDir)) {
        for (const f of readdirSync(libDir)) {
            const p = join(libDir, f);
            try {
                const st = statSync(p);
                if (st.mtimeMs > newest) newest = st.mtimeMs;
            } catch (_) { }
        }
    }
    return newest;
}

/** Return outfile mtime in ms, or 0 if missing. Handles .exe on Windows. */
function getOutputMtime(outfile) {
    for (const p of [outfile, outfile + ".exe"]) {
        if (existsSync(p)) return statSync(p).mtimeMs;
    }
    return 0;
}

async function buildOne({ sourcePath, outName }) {
    // Bun compile ignores directory in outfile, so we use outdir + naming
    const result = await Bun.build({
        entrypoints: [sourcePath],
        outdir: distDir,
        naming: outName,
        minify: true,
        compile: true,
    });
    if (!result.success) {
        console.error(result.logs);
        process.exit(1);
    }
    return result.outputs[0].path;
}

for (const { name, sourcePath } of entries) {
    const outfile = join(distDir, name);
    const outMtime = getOutputMtime(outfile);
    const newestInput = getNewestInputMtime(sourcePath);
    if (outMtime >= newestInput && outMtime > 0) {
        console.log(`Skipping ${sourcePath} (up to date)`);
        continue;
    }
    console.log(`Building ${sourcePath} -> ${outfile}`);
    const outPath = await buildOne({ sourcePath, outName: name });
    console.log(`  -> ${outPath}`);
}

console.log("Build done.");
