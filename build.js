#!/usr/bin/env bun
/**
 * Compile each direct .js in src/ to a standalone executable in dist/.
 * Run: bun run build
 * Skips a target if it is newer than the source entry, mise.local.toml (if present), and all src/lib/*.
 */
import { Glob } from "bun";
import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync, statSync } from "node:fs";
import { join, resolve } from "node:path";

const distDir = resolve(process.cwd(), "dist");
if (!existsSync(distDir)) {
    mkdirSync(distDir, { recursive: true });
}

// Generate src/lib/config.js with build-time defaults from env
function getEnvConfig(name) {
    const val = process.env[name];
    return val != null && val !== "" ? JSON.stringify(val) : "undefined";
}
const configVars = [
    ["DEFAULT_OPENAI_API_KEY", "OPENAI_API_KEY"],
    ["DEFAULT_OPENAI_BASE_URL", "OPENAI_BASE_URL"],
    ["DEFAULT_OPENAI_MODEL", "OPENAI_MODEL"],
    ["DEFAULT_PUSHOVER_USER_KEY", "PUSHOVER_USER_KEY"],
    ["DEFAULT_PUSHOVER_AGENT_TOKEN", "PUSHOVER_AGENT_TOKEN"],
    ["DEFAULT_PUSHOVER_PERSONAL_TOKEN", "PUSHOVER_PERSONAL_TOKEN"],
];
const configSource =
    `/**
 * Build-time defaults generated by build.js.
 * DO NOT EDIT â€” this file is gitignored and regenerated on build.
 */
` +
    configVars
        .map(([exportName, envName]) => `export const ${exportName} = ${getEnvConfig(envName)};`)
        .join("\n") +
    "\n";
const configPath = "./src/lib/config.js";
let existingConfig = "";
try {
    existingConfig = readFileSync(configPath, "utf-8");
} catch (_) { }
if (existingConfig !== configSource) {
    writeFileSync(configPath, configSource);
    console.log("Generated src/lib/config.js");
} else {
    console.log("src/lib/config.js unchanged");
}

// Direct .js files under src/ to compile
const srcDir = join(process.cwd(), "src");
const entries = [];
const glob = new Glob("*.js");
for await (const file of glob.scan(srcDir)) {
    entries.push({
        name: file.slice(0, -3),
        sourcePath: join(srcDir, file),
    });
}
const privateSrcDir = join(process.cwd(), "..", "private", "src");
if (existsSync(privateSrcDir)) {
    for (const f of readdirSync(privateSrcDir)) {
        if (!f.endsWith(".js")) continue;
        entries.push({
            name: f.slice(0, -3),
            sourcePath: join(privateSrcDir, f),
        });
    }
}

const libDir = join(process.cwd(), "src", "lib");
const miseLocalPath = join(process.cwd(), "mise.local.toml");

/** Return the newest mtime among source entry, mise.local.toml (if any), and all files in src/lib. */
function getNewestInputMtime(sourcePath) {
    let newest = 0;
    try {
        const s = statSync(sourcePath);
        if (s.mtimeMs > newest) newest = s.mtimeMs;
    } catch (_) { }
    if (existsSync(miseLocalPath)) {
        const m = statSync(miseLocalPath).mtimeMs;
        if (m > newest) newest = m;
    }
    if (existsSync(libDir)) {
        for (const f of readdirSync(libDir)) {
            const p = join(libDir, f);
            try {
                const st = statSync(p);
                if (st.mtimeMs > newest) newest = st.mtimeMs;
            } catch (_) { }
        }
    }
    return newest;
}

/** Return outfile mtime in ms, or 0 if missing. Handles .exe on Windows. */
function getOutputMtime(outfile) {
    for (const p of [outfile, outfile + ".exe"]) {
        if (existsSync(p)) return statSync(p).mtimeMs;
    }
    return 0;
}

async function buildOne({ sourcePath, outName, outdir = distDir }) {
    const result = await Bun.build({
        entrypoints: [sourcePath],
        outdir,
        naming: outName,
        minify: true,
        compile: true,
    });
    if (!result.success) {
        console.error(result.logs);
        process.exit(1);
    }
    return result.outputs[0].path;
}

async function buildIfStale(entryList, outDir) {
    if (!existsSync(outDir)) {
        mkdirSync(outDir, { recursive: true });
    }
    for (const { name, sourcePath } of entryList) {
        const outfile = join(outDir, name);
        const outMtime = getOutputMtime(outfile);
        const newestInput = getNewestInputMtime(sourcePath);
        if (outMtime >= newestInput && outMtime > 0) {
            console.log(`Skipping ${sourcePath} (up to date)`);
            continue;
        }
        console.log(`Building ${sourcePath} -> ${outfile}`);
        const outPath = await buildOne({ sourcePath, outName: name, outdir: outDir });
        console.log(`  -> ${outPath}`);
    }
}

await buildIfStale(entries, distDir);

const miseTasksSrcDir = join(process.cwd(), "src", "mise-tasks");
const miseTasksDistDir = join(distDir, "mise-tasks");
if (existsSync(miseTasksSrcDir)) {
    const miseEntries = readdirSync(miseTasksSrcDir)
        .filter((f) => f.endsWith(".js"))
        .map((f) => ({ name: f.slice(0, -3), sourcePath: join(miseTasksSrcDir, f) }));
    await buildIfStale(miseEntries, miseTasksDistDir);
}

console.log("Build done.");
